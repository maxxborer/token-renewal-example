# Тестовые сценарии для Token Renewal

## 1. Базовые сценарии

### 1.1 Успешное обновление токена

**Шаги:**

1. Войти в систему (demo/demo)
2. Нажать "Протухнуть слабо"
3. Выполнить любой запрос (GET /api/users)

**Ожидаемый результат:**

- Запрос получает 401
- Автоматически выполняется refresh токена
- Исходный запрос повторяется с новым токеном
- Пользователь получает данные без прерывания работы

### 1.2 Неудачное обновление токена

**Шаги:**

1. Войти в систему
2. Нажать "Протухнуть сильно"
3. Выполнить любой запрос

**Ожидаемый результат:**

- Запрос получает 401
- Попытка refresh токена возвращает ошибку
- Пользователь перенаправляется на страницу входа
- Все pending запросы отклоняются

## 2. Параллельные запросы

### 2.1 Множественные 401 ошибки одновременно

**Шаги:**

1. Войти в систему
2. Нажать "Протухнуть слабо"
3. Нажать "Параллельные запросы (3 шт)"

**Ожидаемый результат:**

- Все 3 запроса получают 401
- Выполняется ТОЛЬКО ОДИН refresh запрос
- Остальные запросы ждут в очереди
- После успешного refresh все 3 запроса повторяются
- Все запросы успешно завершаются

### 2.2 Параллельные запросы с разными методами

**Шаги:**

1. Войти в систему
2. Нажать "Протухнуть слабо"
3. Одновременно запустить:
   - GET запрос
   - POST запрос
   - GraphQL query
   - GraphQL mutation

**Ожидаемый результат:**

- Один refresh для всех типов запросов
- Сохранение оригинальных данных каждого запроса
- Корректное выполнение всех типов запросов после refresh

## 3. Отмена запросов

### 3.1 Отмена во время ожидания refresh

**Шаги:**

1. Войти в систему
2. Нажать "Протухнуть слабо"
3. Нажать "Тест отмены запроса"

**Ожидаемый результат:**

- Запрос отменяется через AbortController
- Запрос НЕ добавляется в очередь повтора
- Нет ошибок в консоли
- Отображается "Запрос успешно отменён"

### 3.2 Отмена параллельных запросов

**Шаги:**

1. Создать несколько запросов с индивидуальными AbortController
2. Отменить часть запросов во время refresh

**Ожидаемый результат:**

- Отменённые запросы не повторяются
- Неотменённые запросы успешно завершаются
- Очередь корректно очищается от отменённых запросов

## 4. Edge Cases

### 4.1 Двойной клик (race condition)

**Шаги:**

1. Войти в систему
2. Нажать "Протухнуть слабо"
3. Быстро дважды нажать на любую кнопку запроса

**Ожидаемый результат:**

- Оба запроса обрабатываются корректно
- Только один refresh запрос
- Оба запроса получают результат

### 4.2 Refresh во время refresh

**Шаги:**

1. Модифицировать сервер для медленного refresh (добавить задержку)
2. Запустить запрос, получить 401
3. Во время refresh запустить ещё несколько запросов

**Ожидаемый результат:**

- Новые запросы добавляются в очередь
- НЕ запускается второй refresh
- Все запросы выполняются после первого refresh

### 4.3 Смена пользователя во время refresh

**Шаги:**

1. Залогиниться как user1
2. Протухнуть токен слабо
3. Запустить запрос (начнётся refresh)
4. В другой вкладке выйти и войти как user2

**Ожидаемый результат:**

- Refresh для user1 завершается
- Запросы user1 могут fail (это нормально)
- Система остаётся в консистентном состоянии

## 5. Специфичные сценарии

### 5.1 Запросы с большим payload

**Шаги:**

1. Создать POST запрос с большим объёмом данных
2. Получить 401 и дождаться refresh
3. Проверить повторный запрос

**Ожидаемый результат:**

- Весь payload сохраняется
- Повторный запрос идентичен оригинальному
- Данные не теряются и не искажаются

### 5.2 Запросы с custom headers

**Шаги:**

1. Выполнить запрос с дополнительными заголовками
2. Получить 401 и refresh

**Ожидаемый результат:**

- Все заголовки сохраняются
- Повторный запрос содержит те же заголовки

### 5.3 Upload файлов

**Шаги:**

1. Реализовать endpoint для загрузки файлов
2. Начать upload, получить 401
3. Проверить повторную отправку

**Ожидаемый результат:**

- FormData сохраняется корректно
- Файл отправляется повторно
- Progress события работают корректно

## 6. GraphQL специфика

### 6.1 Батчинг запросов

**Шаги:**

1. Настроить Apollo для батчинга
2. Отправить несколько queries в батче
3. Получить 401

**Ожидаемый результат:**

- Весь батч обрабатывается как один запрос
- После refresh батч повторяется целиком
- Все queries в батче получают результаты

### 6.2 Subscriptions

**Шаги:**

1. Установить GraphQL subscription
2. Протухнуть токен
3. Проверить переподключение

**Ожидаемый результат:**

- Subscription корректно переподключается
- Не теряются события во время refresh
- WebSocket соединение восстанавливается

## 7. Производительность

### 7.1 Большое количество запросов в очереди

**Шаги:**

1. Создать 50+ одновременных запросов
2. Все получают 401
3. Измерить время выполнения

**Ожидаемый результат:**

- Только один refresh запрос
- Все запросы успешно выполняются
- Нет утечек памяти
- Производительность остаётся приемлемой

### 7.2 Долгий refresh

**Шаги:**

1. Сделать refresh медленным (5+ секунд)
2. Накопить много запросов в очереди
3. Отменить часть из них

**Ожидаемый результат:**

- Отменённые запросы корректно удаляются из очереди
- Память освобождается
- Активные запросы выполняются после refresh

## 8. Безопасность

### 8.1 Попытка обхода авторизации

**Шаги:**

1. Пометить запрос флагом `_skipAuth`
2. Отправить на защищённый endpoint

**Ожидаемый результат:**

- Сервер всё равно проверяет токен
- 401 НЕ перехватывается на клиенте
- Запрос fail без попытки refresh

### 8.2 XSS через error messages

**Шаги:**

1. Сервер возвращает 401 с XSS в сообщении
2. Проверить отображение ошибок

**Ожидаемый результат:**

- Сообщения об ошибках экранируются
- XSS не выполняется
- Безопасное отображение ошибок

## 9. Интеграционные тесты

### 9.1 Работа с внешними библиотеками

**Шаги:**

1. Использовать сторонние Axios plugins
2. Проверить совместимость с interceptors

**Ожидаемый результат:**

- Token renewal не конфликтует с другими interceptors
- Порядок выполнения сохраняется
- Функциональность обеих систем работает

### 9.2 SSR совместимость

**Шаги:**

1. Запустить в SSR окружении (Nuxt.js с Vue)
2. Проверить работу на сервере и клиенте

**Ожидаемый результат:**

- Корректная работа в обеих средах
- Нет ошибок при гидратации
- Токены правильно передаются между server/client

## 10. Мониторинг и логирование

### 10.1 Отслеживание метрик

**Тестируемые метрики:**

- Количество refresh запросов
- Время выполнения refresh
- Количество повторных попыток
- Процент успешных refresh

**Ожидаемый результат:**

- Все метрики собираются корректно
- Можно построить дашборд мониторинга
- Аномалии легко обнаруживаются

### 10.2 Debug режим

**Шаги:**

1. Включить debug логирование
2. Выполнить различные сценарии
3. Проверить полноту логов

**Ожидаемый результат:**

- Детальные логи всех этапов
- Понятная последовательность действий
- Достаточно информации для debugging
